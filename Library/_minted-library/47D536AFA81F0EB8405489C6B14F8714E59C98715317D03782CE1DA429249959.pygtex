\begin{Verbatim}[commandchars=\\\{\},codes={\catcode`\$=3\catcode`\^=7\catcode`\_=8\relax}]
\PYG{c+cm}{/* The following version answers range\PYGZhy{}maximum queries}
\PYG{c+cm}{It supports single\PYGZhy{}element\PYGZhy{}update and range\PYGZhy{}retrieval, both in O(log n).}

\PYG{c+cm}{The actual data stored in the node (in this version) is not the value}
\PYG{c+cm}{of the maximum element in the range represented by this node. It\PYGZsq{}s}
\PYG{c+cm}{the index of that maximum element.}

\PYG{c+cm}{Range Maximum (or Minimum) Queries is used in problems such as:}
\PYG{c+cm}{\PYGZhy{} largest rectangle in a histogram}
\PYG{c+cm}{\PYGZhy{} lowest common ancestor in a tree}
\PYG{c+cm}{*/}
\PYG{c+cp}{\PYGZsh{}define MAX 105}
\PYG{c+cp}{\PYGZsh{}define left(s) (s \PYGZlt{}\PYGZlt{} 1)}
\PYG{c+cp}{\PYGZsh{}define right(s) ((s \PYGZlt{}\PYGZlt{} 1) + 1)}
\PYG{c+cp}{\PYGZsh{}define avg(a, b) ((a + b) \PYGZgt{}\PYGZgt{} 1)}
\PYG{c+c1}{// we are using 0\PYGZhy{}based indexing}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{       }\PYG{c+c1}{// size of my array}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{[}\PYG{n}{MAX}\PYG{p}{];}\PYG{+w}{  }\PYG{c+c1}{// actual array}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{st}\PYG{p}{[}\PYG{n}{MAX}\PYG{p}{];}\PYG{+w}{ }\PYG{c+c1}{// segment tree array (implemented as a binary heap)}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{build}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{l}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{)\PYGZob{}}
\PYG{+w}{	}\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{l}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{)}
\PYG{+w}{	}\PYG{p}{\PYGZob{}}
\PYG{+w}{		}\PYG{c+c1}{// interval has one element, so}
\PYG{+w}{		}\PYG{c+c1}{// the index of the maximum element in the interval}
\PYG{+w}{		}\PYG{c+c1}{// is the index of that only element}
\PYG{+w}{		}\PYG{n}{st}\PYG{p}{[}\PYG{n}{p}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{l}\PYG{p}{;}
\PYG{+w}{		}\PYG{k}{return}\PYG{p}{;}
\PYG{+w}{	}\PYG{p}{\PYGZcb{}}
\PYG{+w}{	}
\PYG{+w}{	}\PYG{c+c1}{// otherwise:}
\PYG{+w}{	}\PYG{n}{build}\PYG{p}{(}\PYG{n}{left}\PYG{p}{(}\PYG{n}{p}\PYG{p}{),}\PYG{+w}{ }\PYG{n}{l}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{avg}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{));}\PYG{+w}{      }\PYG{c+c1}{// build left subtree}
\PYG{+w}{	}\PYG{n}{build}\PYG{p}{(}\PYG{n}{right}\PYG{p}{(}\PYG{n}{p}\PYG{p}{),}\PYG{+w}{ }\PYG{n}{avg}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{);}\PYG{+w}{ }\PYG{c+c1}{// build right subtree}
\PYG{+w}{	}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{p1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{st}\PYG{p}{[}\PYG{n}{left}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)],}\PYG{+w}{  }\PYG{c+c1}{// index of maximum element in left subtree}
\PYG{+w}{	    }\PYG{n}{p2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{st}\PYG{p}{[}\PYG{n}{right}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)];}\PYG{+w}{ }\PYG{c+c1}{// index of maximum element in right subtree}
\PYG{+w}{	}
\PYG{+w}{	}\PYG{c+c1}{// choose the maximum of both}
\PYG{+w}{	}\PYG{n}{st}\PYG{p}{[}\PYG{n}{p}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{n}{p1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{[}\PYG{n}{p2}\PYG{p}{])}\PYG{+w}{ }\PYG{o}{?}\PYG{+w}{ }\PYG{n}{p1}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{p2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{j}\PYG{p}{;}\PYG{+w}{	}\PYG{c+cm}{/* query boundaries}
\PYG{c+cm}{To query the tree, set your boundaries and invoke rmq(1, 0, n\PYGZhy{}1)}
\PYG{c+cm}{the indeces of the tree nodes, like binary heaps, have to be 1\PYGZhy{}based}
\PYG{c+cm}{however, the indeces of the array could be either 1 or 0\PYGZhy{}based}
\PYG{c+cm}{*/}

\PYG{c+c1}{// rmq stands for range maximum (or minimum) query}
\PYG{c+c1}{// to get the index of the maximum element in a range,}
\PYG{c+c1}{// set i and j to the boundaries of that range, and}
\PYG{c+c1}{// the answer will be rmq(1, 0, n \PYGZhy{} 1)}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{rmq}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{l}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{c+c1}{// O(log n)}

\PYG{+w}{	}\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{r}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{l}\PYG{p}{)}
\PYG{+w}{		}\PYG{c+c1}{// outside query range, so return an invalid value}
\PYG{+w}{		}\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}

\PYG{+w}{	}\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{l}\PYG{+w}{ }\PYG{o}{\PYGZgt{}=}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{\PYGZlt{}=}\PYG{+w}{ }\PYG{n}{j}\PYG{p}{)}
\PYG{+w}{		}\PYG{c+c1}{// inside query range}
\PYG{+w}{		}\PYG{c+c1}{// you already have the value stored, so return it directly}
\PYG{+w}{		}\PYG{k}{return}\PYG{+w}{ }\PYG{n}{st}\PYG{p}{[}\PYG{n}{p}\PYG{p}{];}
\PYG{+w}{		}
\PYG{+w}{	}\PYG{c+c1}{// otherwise, recurse}
\PYG{+w}{	}\PYG{c+c1}{// get index of maximum element in left subtree}
\PYG{+w}{	}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{p1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{rmq}\PYG{p}{(}\PYG{n}{left}\PYG{p}{(}\PYG{n}{p}\PYG{p}{),}\PYG{+w}{ }\PYG{n}{l}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{avg}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{));}
\PYG{+w}{	}\PYG{c+c1}{// get index of maximum element in right subtree}
\PYG{+w}{	}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{p2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{rmq}\PYG{p}{(}\PYG{n}{right}\PYG{p}{(}\PYG{n}{p}\PYG{p}{),}\PYG{+w}{ }\PYG{n}{avg}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{);}
\PYG{+w}{	}\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{p1}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{)}
\PYG{+w}{		}\PYG{c+c1}{// if left segment lies all outside query range,}
\PYG{+w}{		}\PYG{c+c1}{// return result of right subtree}
\PYG{+w}{		}\PYG{k}{return}\PYG{+w}{ }\PYG{n}{p2}\PYG{p}{;}
\PYG{+w}{	}\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{p2}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{)}
\PYG{+w}{		}\PYG{c+c1}{// if right segment lies all outside query range,}
\PYG{+w}{		}\PYG{c+c1}{// return result of left subree}
\PYG{+w}{		}\PYG{k}{return}\PYG{+w}{ }\PYG{n}{p1}\PYG{p}{;}
\PYG{+w}{	}\PYG{c+c1}{// otherwise, return the maximum of both}
\PYG{+w}{	}\PYG{k}{return}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{n}{p1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{[}\PYG{n}{p2}\PYG{p}{])}\PYG{+w}{ }\PYG{o}{?}\PYG{+w}{ }\PYG{n}{p1}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{p2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// assuming, we want to update the value of arr[i]}
\PYG{c+c1}{// just set arr[i] = new value}
\PYG{c+c1}{// then call update(1, 0, n \PYGZhy{} 1);}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{update}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{l}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{)}
\PYG{p}{\PYGZob{}}\PYG{+w}{	}
\PYG{+w}{	}\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{l}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{)}
\PYG{+w}{		}\PYG{c+c1}{// updated element is outside the range of this node}
\PYG{+w}{		}\PYG{k}{return}\PYG{p}{;}
\PYG{+w}{	}\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{l}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{)}
\PYG{+w}{		}\PYG{c+c1}{// if you are a leaf node (have no children),}
\PYG{+w}{		}\PYG{c+c1}{// you don\PYGZsq{}t need to update because you value is}
\PYG{+w}{		}\PYG{c+c1}{// fixed (st[p] = l)}
\PYG{+w}{		}\PYG{k}{return}\PYG{p}{;}

\PYG{+w}{	}\PYG{c+c1}{// otherwise, you have children and the updated element}
\PYG{+w}{	}\PYG{c+c1}{// lies inside the segment you represent}
\PYG{+w}{	}\PYG{c+c1}{// so update your children}
\PYG{+w}{	}\PYG{n}{update}\PYG{p}{(}\PYG{n}{left}\PYG{p}{(}\PYG{n}{p}\PYG{p}{),}\PYG{+w}{ }\PYG{n}{l}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{avg}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{));}
\PYG{+w}{	}\PYG{n}{update}\PYG{p}{(}\PYG{n}{right}\PYG{p}{(}\PYG{n}{p}\PYG{p}{),}\PYG{+w}{ }\PYG{n}{avg}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{);}
\PYG{+w}{	}\PYG{c+c1}{// then update your value}
\PYG{+w}{	}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{p1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{st}\PYG{p}{[}\PYG{n}{left}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)],}
\PYG{+w}{	}\PYG{n}{p2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{st}\PYG{p}{[}\PYG{n}{right}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)];}
\PYG{+w}{	}\PYG{n}{st}\PYG{p}{[}\PYG{n}{p}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{n}{p1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{[}\PYG{n}{p2}\PYG{p}{])}\PYG{+w}{ }\PYG{o}{?}\PYG{+w}{ }\PYG{n}{p1}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{p2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
